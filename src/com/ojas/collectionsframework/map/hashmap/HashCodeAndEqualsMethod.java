package com.ojas.collectionsframework.map.hashmap;

import java.util.HashMap;
import java.util.Objects;

public class HashCodeAndEqualsMethod {
    public static void main(String[] args) {
        HashMap<Person, String> map = new HashMap<>();
        Person p1 = new Person("Ojashwa", 1);
        Person p2 = new Person("Tejashwa", 2);
        Person p3 = new Person("Ojashwa", 1);

        map.put(p1,"Engineer"); // hashcode1--> index1
        map.put(p2, "Student"); // hashcode2 --> index2
        map.put(p3, "Teacher"); // hashcode1 --> index1 --> equals --> replace [after overriding the hashcode() and equals() methods]

        // The hashcode of the person object will be generated by manipulating the memory address internally by java
        // So even though p1 and p3 have same String and int value they will be treated like different objects due to
        // them being dynamically created objects.
        // Hence, to tell java that p1 and p3 are the same persons we will have to override
        // the Object class's hashcode() and equals() methods for correct implementation

        System.out.println("Hashmap size: " + map.size());
        System.out.println("Value for p1: " + map.get(p1));
        System.out.println("Value for p3: " + map.get(p3));

     /*   HashMap<String, Integer> map1 = new HashMap<>();
        map1.put("Shyam", 90);
        map1.put("Rohan", 91);
        map1.put("Shyam",99);

        System.out.println(map1.size());
        System.out.println("Shayam's marks: " + map1.get("Shyam"));

        In normal cases like this where we don't have custom classes we don't need to
        define our own hashcode() and equals() methods java's built-in classes like String, Integer do that for us
        { even if you do new String("Shyam") }.
        Because, for java "Shyam" is unique (from string pool and uses .equals()) unlike p1 and p3 that were treated differently
        due to them being considered separate objects
        */
    }
}

class Person{
    private String name;
    private int id;

    public Person(String name, int id){
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(name);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj){
            return true;
        }
        if (obj == null){
            return false;
        }
        if (this.getClass() != obj.getClass()){
            return false;
        }

        Person other = (Person) obj;
        return this.id == ((Person) obj).getId() && Objects.equals(this.name, other.getName());
        // we have used Objects utility class (instead of this.name.equals(obj.getName())) to avoid
        // null pointer exception in case someone's name is null.
    }

    @Override
    public String toString() {
        return "id: " + this.id +", name: " + this.name;
    }
}